import { Notes, Image, Split } from "mdx-deck";
import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import {
  vsDark,
  github,
  nightOwl,
} from "@code-surfer/themes";

import Author from "./slides/Author";
import TableOfContents from "./slides/TableOfContents";

import OneEndpoint from "./slides/OneEndpoint/";
import MountingExample from "./slides/MountingExample";
import MutationExample from "./slides/MutationExample/";
import OnDemandExample from "./slides/OnDemandExample/";
import ClientAlternatives from "./slides//ClientAlternatives/";
import SimpleProfilePlaceholder from "./components/ui/SimpleProfilePlaceholder";
import QueryAndMutationExample from "./slides/QueryAndMutationExample";
import AST from './assets/images/AST.png'; // with import
import JSFromAST from "./assets/images/JSFromAST.png";

export const theme = nightOwl;

# Functional Programming, React, and Compilers in ReasonML

---

<Author />

---

## Reason

- New syntax for OCaml that looks like JS
- "Mostly" functional (OCaml)
- 100% type coverage, inference, and soundness

---

<TableOfContents activeStep={0} />

---

## [The Functional Approach to Programming](https://www.vitalsource.com/products/the-functional-approach-to-programming-guy-cousineau-v9781107263796?duration=perpetual&utm_source=bing&utm_medium=cpc&utm_campaign=VST%20Tier%20Three%20Shopping&msclkid=3983b13c94dd139dbcf8efba3a4a3980)

- Functions as first-class citizens

- Pure functions

- Immutability

---

## Functions are first-class citizens

<CodeSurfer>

```reason
// Reason array
let arr = [|1, 2, 3|];

// This is a function
let double = elem => elem*2;

let doubledArr = Array.map(double, arr); // [2, 4, 6]
```

</CodeSurfer>


---

## Functions are first-class citizens cont'd

<CodeSurfer>

```reason
let add = (x, y) => x + y;
let addFive = add(5);
let eleven = addFive(6);
let twelve = addFive(7);
```

</CodeSurfer>

<Notes>
add above is really syntax sugar for let add = (x) => (y) => x + y;
</Notes>


---

## Pure functions and side effects

<CodeSurfer>

```reason
// Invalid Reason
let incrementValue = value => {
  value++
};

// Valid Reason
let incrementValue = value => {
  value + 1
};
```

</CodeSurfer>

<Notes>
Pure Functions: No side effects occur throughout the function's
execution. A side effect is basically a state change in something other than the
function that's currently executing it. Also, same result for same input.

Here we're trying to change the state of a variable..
</Notes>

---

## Immutable data

<CodeSurfer>

```reason
let x = 5;

// Rest of your program

Js.log(x); // 5
```

</CodeSurfer>

<Notes>
Variables will always be of same value + type throughout the program. This is
very mathematical in nature (what does it mean to be a variable and function in
mathematics).
</Notes>

---

<TableOfContents activeStep={1} />

---

## Why write a compiler?

- Show off the core features of Reason
- It's what Reason/OCaml is especially good at
- TODO throw some pictures of compilers/software written in OCaml

<Notes>
Hack, Haxe, Flow, Infer, Coq, WebAssembly interpreter
</Notes>

---

## What's in a compiler (condensed)

1. Lexer/Tokenizer
2. Parser
3. Code Generation
4. TODO throw in an image here instead (or some animations)

---

## Define your frontend and backend (and sometimes your type system)

- Frontend: Mini-C 
- Type System: N/A
- Backend: JavaScript

---

## Lexer/Tokenizer

Let's define the tokens of our language

```C
def f() 1 end
```

<Notes>
</Notes>

---

How do we represent these tokens?
```
def
f
(
)
1
end
```

We use what's called a [variant](https://reasonml.github.io/docs/en/variant#docsNav)

---


<CodeSurfer>

```reason 3:8 title="Variant"
// Tokenizer.re

type token =
  | DEF // def
  | IDENT // f
  | OPAREN // (
  | CPAREN // )
  | END // end
  | INT // 2,3,etc
  | COMMA; // ,
```

```reason 7:8 title="Variant"
type token =
  | DEF // def
  | IDENT // f
  | OPAREN // (
  | CPAREN // )
  | END // end
  | INT // 2,3,etc
  | COMMA; // ,
```

</CodeSurfer>

<Notes>
Smallest pieces that are meaningful
</Notes>

---

How are we going to consume our input program? [Regular expressions](https://reasonml.github.io/docs/en/regular-expression#docsNav).

<CodeSurfer>

```reason
//Tokenizer.re

type tokenType = {
  token,
  regExp: Js.Re.t,
};

type tokenValue = {
  token,
  value: string,
};

// ^ means match beginning of input
let defToken = {token: `DEF, regExp: [%re "/^(\\bdef\\b)/"]};
let endToken = {token: `END, regExp: [%re "/^(\\bend\\b)/"]};
let identToken = {token: `IDENT, regExp: [%re "/^(\\b[a-zA-Z]+\\b)/"]};
let intToken = {token: `INT, regExp: [%re "/^(\\b[0-9]+\\b)/"]};
let oparenToken = {token: `OPAREN, regExp: [%re "/^(\\()/"]};
let cparenToken = {token: `CPAREN, regExp: [%re "/^(\\))/"]};
let commaToken = {token: `COMMA, regExp: [%re "/^(\\,)/"]};

// These are in a necessary order, i.e. don't want def to be an identifier
let tokenTypes: array(tokenType) = [|
  defToken,
  endToken,
  identToken,
  intToken,
  oparenToken,
  cparenToken,
  commaToken,
|];
```

```reason 1:9
type tokenType = {
  token,
  regExp: Js.Re.t,
};

type tokenValue = {
  token,
  value: string,
};

// ^ means match beginning of input
let defToken = {token: `DEF, regExp: [%re "/^(\\bdef\\b)/"]};
let endToken = {token: `END, regExp: [%re "/^(\\bend\\b)/"]};
let identToken = {token: `IDENT, regExp: [%re "/^(\\b[a-zA-Z]+\\b)/"]};
let intToken = {token: `INT, regExp: [%re "/^(\\b[0-9]+\\b)/"]};
let oparenToken = {token: `OPAREN, regExp: [%re "/^(\\()/"]};
let cparenToken = {token: `CPAREN, regExp: [%re "/^(\\))/"]};
let commaToken = {token: `COMMA, regExp: [%re "/^(\\,)/"]};

// These are in a necessary order, i.e. don't want def to be an identifier
let tokenTypes: array(tokenType) = [|
  defToken,
  endToken,
  identToken,
  intToken,
  oparenToken,
  cparenToken,
  commaToken,
|];
```

```reason 10:32
// These are records
type tokenType = {
  token,
  regExp: Js.Re.t,
};

type tokenValue = {
  token,
  value: string,
};

// ^ means match beginning of input
let defToken = {token: `DEF, regExp: [%re "/^(\\bdef\\b)/"]};
let endToken = {token: `END, regExp: [%re "/^(\\bend\\b)/"]};
let identToken = {token: `IDENT, regExp: [%re "/^(\\b[a-zA-Z]+\\b)/"]};
let intToken = {token: `INT, regExp: [%re "/^(\\b[0-9]+\\b)/"]};
let oparenToken = {token: `OPAREN, regExp: [%re "/^(\\()/"]};
let cparenToken = {token: `CPAREN, regExp: [%re "/^(\\))/"]};
let commaToken = {token: `COMMA, regExp: [%re "/^(\\,)/"]};

// These are in a necessary order, i.e. don't want def to be an identifier
let tokenTypes: array(tokenType) = [|
  defToken,
  endToken,
  identToken,
  intToken,
  oparenToken,
  cparenToken,
  commaToken,
|];
```

</CodeSurfer>

---

Now we throw it through a tokenizer function and...


<CodeSurfer>

```reason
// Compiler.re

let program = "def f(x,y,z) 1 end";
let tokens = Tokenizer.make(program);
Js.log(tokens);
```

</CodeSurfer>

---

<CodeSurfer>

```json title="Tokens!"
[
  { token: 3397029, value: 'def' },
  { token: 895974096, value: 'f' },
  { token: -780845765, value: '(' },
  { token: 895974096, value: 'x' },
  { token: -934581835, value: ',' },
  { token: 895974096, value: 'y' },
  { token: -934581835, value: ',' },
  { token: 895974096, value: 'z' },
  { token: 86829255, value: ')' },
  { token: 895974096, value: 'g' },
  { token: -780845765, value: '(' },
  { token: 895974096, value: 'x' },
  { token: -934581835, value: ',' },
  { token: 895974096, value: 'y' },
  { token: -934581835, value: ',' },
  { token: 3647695, value: '1' },
  { token: 86829255, value: ')' },
  { token: 3448763, value: 'end' }
]
```

</CodeSurfer>

---

## Any questions?

---

## On to the parser

The parser will analyze our sequence of tokens and create a tree representing
the input program (also known as an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree)).

TODO put an image of a AST here

---

<CodeSurfer>

```reason title="Types"
type integerNode = {value: int}
and callNode = {
  name: string,
  argExprs: array(exprNode),
}
and varRefNode = {value: string}
and exprNode =
  | callNode
  | integerNode
  | varRefNode;

type defNode = {
  name: string,
  argNames: array(string),
  body: exprNode,
};

type node =
  | Def(defNode)
  | Expr(exprNode);
```

```reason 1:16 title="Types"
type integerNode = {value: int}
and callNode = {
  name: string,
  argExprs: array(exprNode),
}
and varRefNode = {value: string}
and exprNode =
  | callNode
  | integerNode
  | varRefNode;

type defNode = {
  name: string,
  argNames: array(string),
  body: exprNode,
};

type node =
  | Def(defNode)
  | Expr(exprNode);
```

```reason 17:20 title="Types"
type integerNode = {value: int}
and callNode = {
  name: string,
  argExprs: array(exprNode),
}
and varRefNode = {value: string}
and exprNode =
  | callNode
  | integerNode
  | varRefNode;

type defNode = {
  name: string,
  argNames: array(string),
  body: exprNode,
};

type node =
  | Def(defNode)
  | Expr(exprNode);
```

</CodeSurfer>

---

Remember, we want to turn this;

```
def f(x) 1 end
```

into something like this:

```
DEF
  NAME: "f"
  ARGS: ["x"]
  BODY:
    INTEGER_LITERAL: "1"
```

---

<CodeSurfer>

```reason title="How do we parse integers?"
let parseInteger = tokens => {
  let (integerToken, newTokens) = consume(tokens, INT);
  let integerNode: integerNode  = {value: int_of_string(integerToken.value)};
  (ExprNode(integerNode), newTokens);
};
```

```reason 2 title="Consume the INT token"
let parseInteger = tokens => {
  let (integerToken, newTokens) = consume(tokens, INT);
  let integerNode: integerNode  = {value: int_of_string(integerToken.value)};
  (ExprNode(integerNode), newTokens);
};
```

```reason 3 title="Build the integerNode"
let parseInteger = tokens => {
  let (integerToken, newTokens) = consume(tokens, INT);
  let integerNode: integerNode  = {value: int_of_string(integerToken.value)};
  (ExprNode(integerNode), newTokens);
};
```

```reason 4 title="Construct an ExprNode"
let parseInteger = tokens => {
  let (integerToken, newTokens) = consume(tokens, INT);
  let integerNode: integerNode  = {value: int_of_string(integerToken.value)};
  (ExprNode(integerNode), newTokens);
};
```


</CodeSurfer>

---

<CodeSurfer>

```reason title="How do we parse expressions?"
let parseExpr = tokens =>
  if (peek(tokens, `INT, ())) {
    parseInteger(tokens);
  } else {
    parseCall(tokens);
  };
```

</CodeSurfer>

---

## Let's put it all together and create our AST


---

<CodeSurfer>

```reason title="Parser"
// Will return a tree
let make = (tokens: array(tokenValue)) => {
  let rec parse = tokens => {
    // Start with parseDef
    let (parsedDef, _) = parseDef(tokens);
    [|parsedDef|];
  };
  parse(tokens);
};
```

```reason 3:7 title="Recursive parse function"
// Will return a tree
let make = (tokens: array(tokenValue)) => {
  let rec parse = tokens => {
    // Start with parseDef
    let (parsedDef, _) = parseDef(tokens);
    [|parsedDef|];
  };
  parse(tokens);
};
```

```reason 8 title="Call the recursive function and..."
// Will return a tree
let make = (tokens: array(tokenValue)) => {
  let rec parse = tokens => {
    // Start with parseDef
    let (parsedDef, _) = parseDef(tokens);
    [|parsedDef|];
  };
  parse(tokens);
};
```

</CodeSurfer>

---

For an input of 
```
def f(x) ) end
```

we get this Abstract Syntax Tree:

```
DefNode(
  {
    name: "f"
    argNames: "x"
    body: ExprNode(
      {
        value: 1        
      }
    )
  } 
)
```

---

## Questions so far?

---

## Now we're going to generate JavaScript from our input AST

<div class="flex flex-row">
  <img src={AST} />
  <img src={JSFromAST} />
</div>

---



---

## Reason/OCaml Type system

- Full type coverage
- Inference
- Soundness 

<Notes>
Contrast this with JavaScript
</Notes>

---


---

<TableOfContents activeStep={2} />

---


## Core concepts of React

1. Minimize application state
2. Minimize side effects

<Notes>
Jordan Walke did a talk, invented React and Reason etc.
</Notes>

---

<CodeSurfer>

```reason
[@react.component]
let make = (~name) => {
  let (count, setCount) = React.useState(() => 0);

  <div>
    <p> {React.string(name ++ " clicked " ++ string_of_int(count) ++ " times")} </p>
    <button onClick={_ => setCount(_ => count + 1)}>
      {React.string("Click me")}
    </button>
  </div>
};
```
</CodeSurfer>

<Notes>
</Notes>


## ReasonReact

<CodeSurfer>

```reason
[@react.component]
let make = (~name) => {
  let (count, setCount) = React.useState(() => 0);

  <div>
    <p> {React.string(name ++ " clicked " ++ string_of_int(count) ++ " times")} </p>
    <button onClick={_ => setCount(_ => count + 1)}>
      {React.string("Click me")}
    </button>
  </div>
};
```
</CodeSurfer>

<Notes>
</Notes>

---

# Sources

- https://thecodeboss.dev/2016/12/core-functional-programming-concepts/


